{...
# encoding: UTF-8
require 'markov_chain'
require 'stringio'

class ChatBot
  
  private_class_method :new
  
  #
  # +data+ is a map. It may be empty, in this case a brand new ChatBot is
  # created. +data+ becomes owned by the returned ChatBot.
  # 
  def from(data)
    new(data)
  end
  
  # :nonew:
  def initialize(data)
    @markov_chain =
      if data.empty? then MarkovChain.new(data)
      else MarkovChain.from(data)
      end
  end
  
  # +data+ passed to #from().
  def data
    @markov_chain.data
  end
  
  private
  
  class Token < Struct.new(:value); end
  class Word < Token; end
  class PunctuationMark < Token; end
  class End < Token; end
  
  #
  # returns Array of Token-s.
  # 
  def tokenize(text)
    yy_parse(StringIO.new(text))
  end
  
}...

text: Array[Token] =
  { val = [] }
  (
    / word:w { val << Word.new(w) }
    / punctuation-mark:p { val << PunctuationMark.new(p) }
    / white-space+
  )*
  ;

word: String =
  { val = "" }
  (
    / word-part:>>val
    / '-':(h) &word-part { val << h }
  )+
  ;

word-part: String =
  / 'a'...'z':val
  / 'A'...'Z':val
  / 'а'...'я':val
  / 'А'...'Я':val
  / '0'...'9':val
  ;

punctuation-mark: String =
  { val = "" }
  (white-space:>>val)*
  (!word-part char:>>val)+
  (white-space:>>val)*
  ;

# White space as specified in "Unicode Standard Annex #44: Unicode Character
# Database" (http://www.unicode.org/reports/tr44, specifically
# http://www.unicode.org/Public/UNIDATA/PropList.txt).
white-space: String =
  (
    / U+0009...U+000D
    / U+0020
    / U+0085
    / U+00A0
    / U+1680
    / U+180E
    / U+2000...U+200A
    / U+2028
    / U+2029
    / U+202F
    / U+205F
    / U+3000
  )
  { val = " " }
  ;

{...

end

}...